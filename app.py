# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e56Gc969c1mD2__X2OE2SeYaJExPfEm1
"""

import gradio as gr
import pandas as pd
import numpy as np
# Changed 'pickle' to 'dill' to load models saved with dill
import dill as pickle
import os
import datetime as dt
from prophet import Prophet
import matplotlib.pyplot as plt
import seaborn as sns

# --- CLV Libraries ---
from lifetimes import BetaGeoFitter, GammaGammaFitter
from lifetimes.utils import summary_data_from_transaction_data
from ucimlrepo import fetch_ucirepo

# --- Configuration ---
# IMPORTANT: Update this to where your models are saved on Google Drive
MODELS_DIR = ''
SALES_MODEL_PATH = os.path.join(MODELS_DIR, 'sales_trend_prophet_model.pkl')
TOP_PRODUCTS_PATH = os.path.join(MODELS_DIR, 'top_products.pkl')
# Added paths for CLV models
BG_NBD_MODEL_PATH = os.path.join(MODELS_DIR, 'bg_nbd_model.pkl')
GAMMA_GAMMA_MODEL_PATH = os.path.join(MODELS_DIR, 'gamma_gamma_model.pkl')

# --- Helper Function to Load Models ---
def load_model(path):
    try:
        # Use dill to load the models
        with open(path, 'rb') as f:
            model = pickle.load(f)
        print(f"Loaded model from: {path}")
        return model
    except FileNotFoundError:
        print(f"Error: Model file not found at {path}")
        return None
    except Exception as e:
        print(f"Error loading model from {path}: {e}")
        return None

# --- Global Model Loading ---
print("Attempting to load models...")
sales_model = load_model(SALES_MODEL_PATH)
top_products = load_model(TOP_PRODUCTS_PATH)
# Load CLV models
bg_nbd_model = load_model(BG_NBD_MODEL_PATH)
gamma_gamma_model = load_model(GAMMA_GAMMA_MODEL_PATH)

demand_models = {}
if top_products:
    for p_code in top_products:
        model_path = os.path.join(MODELS_DIR, f'demand_prophet_model_{p_code}.pkl')
        model = load_model(model_path)
        if model:
            demand_models[p_code] = model
        else:
            print(f"Could not load demand model for product {p_code}.")
else:
    print("Could not load top products list.")
print("Model loading complete.")

# --- Plotting Style ---
sns.set_theme(style="whitegrid", palette="pastel")
plt.rcParams['figure.figsize'] = (10, 6)
plt.rcParams['font.size'] = 10

# --- Prediction Functions ---
def predict_overall_sales(periods, output_choice):
    if sales_model is None:
        gr.Warning("Overall sales trend model not loaded.")
        return (gr.DataFrame(value=pd.DataFrame(), visible=False),
                gr.Number(value=0.0, visible=False),
                None,
                None)

    future = sales_model.make_future_dataframe(periods=periods)
    forecast = sales_model.predict(future)

    output_df = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(periods).copy()
    output_df['ds'] = output_df['ds'].dt.strftime('%Y-%m-%d') # Format date
    output_df['yhat'] = output_df['yhat'].round(2)
    output_df['yhat_lower'] = output_df['yhat_lower'].round(2)
    output_df['yhat_upper'] = output_df['yhat_upper'].round(2)

    total_sales_sum = output_df['yhat'].sum().round(2)

    output_df.rename(columns={
        'ds': 'Date',
        'yhat': 'Predicted Daily Sales (Sterling)',
        'yhat_lower': 'Lower Confidence Bound (Sterling)',
        'yhat_upper': 'Upper Confidence Bound (Sterling)'
    }, inplace=True)

    fig1 = sales_model.plot(forecast)
    plt.title('Overall Daily Sales Forecast')
    plt.xlabel('Datestamp')
    plt.ylabel('Total Sales (Sterling)')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()

    fig2 = sales_model.plot_components(forecast)
    plt.suptitle('Overall Sales Forecast Components', y=1.02)
    for ax in fig2.axes:
        ax.set_xlabel('Datestamp')
    plt.tight_layout(rect=[0, 0.03, 1, 0.98])

    return (gr.DataFrame(value=output_df, visible=output_choice == "Detailed Table"),
            gr.Number(value=total_sales_sum, visible=output_choice == "Total Sum for Period"),
            fig1, fig2)

def predict_product_demand(product_code, periods, output_choice):
    if product_code not in demand_models:
        gr.Warning("Invalid or missing product model.")
        return (gr.DataFrame(value=pd.DataFrame(), visible=False),
                gr.Number(value=0.0, visible=False),
                None,
                None)

    model = demand_models[product_code]
    future = model.make_future_dataframe(periods=periods)
    forecast = model.predict(future)

    output_df = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(periods).copy()
    output_df['ds'] = output_df['ds'].dt.strftime('%Y-%m-%d') # Format date
    output_df['yhat'] = output_df['yhat'].round(2)
    output_df['yhat_lower'] = output_df['yhat_lower'].round(2)
    output_df['yhat_upper'] = output_df['yhat_upper'].round(2)

    total_quantity_sum = output_df['yhat'].sum().round(2)

    output_df.rename(columns={
        'ds': 'Date',
        'yhat': 'Predicted Daily Quantity',
        'yhat_lower': 'Lower Confidence Bound (Quantity)',
        'yhat_upper': 'Upper Confidence Bound (Quantity)'
    }, inplace=True)

    fig1 = model.plot(forecast)
    plt.title(f'Demand Forecast for Product {product_code}')
    plt.xlabel('Datestamp')
    plt.ylabel('Quantity Sold')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()

    fig2 = model.plot_components(forecast)
    plt.suptitle(f'Forecast Components for Product {product_code}', y=1.02)
    for ax in fig2.axes:
        ax.set_xlabel('Datestamp')
    plt.tight_layout(rect=[0, 0.03, 1, 0.98])

    return (gr.DataFrame(value=output_df, visible=output_choice == "Detailed Table"),
            gr.Number(value=total_quantity_sum, visible=output_choice == "Total Sum for Period"),
            fig1, fig2)

# --- CLV Prediction Function ---
def predict_clv(periods_to_predict, customers_to_show, customer_id=None): # Added customers_to_show
    if bg_nbd_model is None or gamma_gamma_model is None:
        gr.Warning("CLV models not loaded. Please ensure 'bg_nbd_model.pkl' and 'gamma_gamma_model.pkl' exist.")
        return pd.DataFrame({'CustomerID': [], 'Predicted CLV (£)': []}) # Updated header

    try:
        # Fetch the dataset directly using ucimlrepo for consistency
        print("Fetching dataset from UCI ML Repo for CLV prediction...")
        online_retail = fetch_ucirepo(id=352)
        df = online_retail.data.original
        print("Dataset loaded successfully for CLV prediction!")

        df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
        df['Sales'] = df['Quantity'] * df['UnitPrice']

        # Data Cleaning: Filter out returned orders and handle missing data
        df = df[~df['InvoiceNo'].astype(str).str.contains('C', na=False)]
        df.dropna(subset=['CustomerID'], inplace=True)
        df['CustomerID'] = df['CustomerID'].astype(int)
        df = df[df['Sales'] > 0]
        df = df[df['Quantity'] > 0]

        analysis_end_date = df['InvoiceDate'].max() + dt.timedelta(days=1)
        summary_df = summary_data_from_transaction_data(
            df,
            customer_id_col='CustomerID',
            datetime_col='InvoiceDate',
            monetary_value_col='Sales',
            observation_period_end=analysis_end_date
        )

        # Predict expected future purchases for each customer
        summary_df['predicted_purchases'] = bg_nbd_model.predict(
            periods_to_predict,
            summary_df['frequency'],
            summary_df['recency'],
            summary_df['T']
        )

        # Predict expected average monetary value per transaction
        summary_df_gg_eligible = summary_df[summary_df['frequency'] > 0].copy()
        if not summary_df_gg_eligible.empty:
            summary_df_gg_eligible['predicted_monetary'] = gamma_gamma_model.conditional_expected_average_profit(
                summary_df_gg_eligible['frequency'],
                summary_df_gg_eligible['monetary_value']
            )
            summary_df = summary_df.merge(
                summary_df_gg_eligible[['predicted_monetary']],
                left_index=True,
                right_index=True,
                how='left'
            )
            summary_df['predicted_monetary'].fillna(0, inplace=True)
        else:
            summary_df['predicted_monetary'] = 0.0

        # Calculate CLV: expected purchases * expected monetary value
        summary_df['CLV'] = summary_df['predicted_purchases'] * summary_df['predicted_monetary']

        # Round CLV for display
        summary_df['CLV'] = summary_df['CLV'].round(2)

        # Prepare result_df with relevant columns
        result_df = summary_df[['frequency', 'recency', 'T', 'predicted_purchases', 'predicted_monetary', 'CLV']]
        result_df.index.name = 'CustomerID'

        if customer_id:
            # Convert float input to int for customer ID lookup
            if isinstance(customer_id, float):
                customer_id = int(customer_id)

            if customer_id in result_df.index:
                single_clv = result_df.loc[[customer_id]].reset_index()
                single_clv.rename(columns={'CLV': 'Predicted CLV (£)'}, inplace=True) # Renamed column
                return single_clv[['CustomerID', 'Predicted CLV (£)']]
            else:
                gr.Warning(f"Customer ID {customer_id} not found in the dataset.")
                return pd.DataFrame({'CustomerID': [], 'Predicted CLV (£)': []}) # Updated header
        else:
            overall_clv_df = result_df.sort_values(by='CLV', ascending=False).reset_index()
            # Ensure the number of results does not exceed the total available customers
            num_results = min(customers_to_show, len(overall_clv_df))
            overall_clv_df = overall_clv_df.head(num_results)
            overall_clv_df.rename(columns={'CLV': 'Predicted CLV (£)'}, inplace=True) # Renamed column
            return overall_clv_df[['CustomerID', 'Predicted CLV (£)']]

    except Exception as e:
        gr.Error(f"Error during CLV prediction: {e}")
        return pd.DataFrame({'CustomerID': [], 'Predicted CLV (£)': []})


# --- Gradio UI Layout ---
custom_theme = gr.themes.Soft()

with gr.Blocks(theme=custom_theme, title="AI Powered Analytics Tool") as demo:
    # --- Header ---
    gr.Markdown("""
    # 📈 AI Powered Analytics Tool - By Divit Srivastava

    ## About This App
    ---
    This AI-Driven **Sales**, **Product Demand**, and **Customer Lifetime Value (CLV)** Forecaster is a web application designed to provide comprehensive insights, predicting future sales trends, specific product demand, and the long-term financial potential of customers. It leverages historical transaction data, specifically sourced from the **University of California, Irvine Machine Learning Repository**, applying sophisticated **time-series forecasting techniques** and **probabilistic customer behavior models**. Developed using Python, the app utilizes libraries like **Prophet** for time-series, **Lifetimes** for CLV, **Pandas** for data handling, **Matplotlib** and **Seaborn** for data visualization, and **Gradio** for its interactive web interface. Based on comprehensive data analysis, distinct pre-trained models predict overall store sales, individual top-selling product demand, and the future monetary value of customers, offering crucial insights for business optimization and targeted marketing.

    ## How to Use
    ---
    Welcome to your intelligent analytics tool! To get started with forecasting, simply:

    1.  **Select Your Forecast Tab:** Choose between 'Overall Sales Forecast' to predict store-wide trends, 'Product Demand Forecast' for specific items, or the **'Customer Lifetime Value (CLV) Predictor'** for customer insights.
    2.  **Input Future Days/Months:** Enter the number of future days for sales/demand forecasts, or the number of months for CLV prediction.
    3.  **Choose a Product (for Demand Forecast):** If on the 'Product Demand Forecast' tab, use the dropdown to select a specific top-selling product.
    4.  **Specify CLV Options (for CLV Predictor):** On the CLV tab, you can choose how many top CLV customers to view, or enter a specific Customer ID to see their individual prediction.
    5.  **Click to Forecast/Predict:** Hit the 'Forecast Sales', 'Forecast Demand', or 'Predict CLV' button which will generate and display the prediction.
    """)

    # --- Tabs Section ---
    with gr.Tabs():
        with gr.Tab("Overall Sales Forecast"):
            gr.Markdown("### 🔮 Forecast Overall Sales")
            overall_days = gr.Number(
                label="Enter number of future days to forecast (e.g., 30):",
                value=30,
                minimum=7,
                maximum=365,
                step=7
            )
            overall_output_choice = gr.Radio(
                ["Detailed Table", "Total Sum for Period"],
                label="Choose Output Format",
                value="Detailed Table",
                interactive=True
            )
            overall_btn = gr.Button("Forecast Sales")

            gr.Markdown("""
            **Note on Negative Values:** Negative sales values in the forecast, indicate a **prediction of returned orders** for that period.
            """)

            overall_table = gr.DataFrame(label="Forecast Data Table", visible=True)
            overall_total_output = gr.Number(label="Total Forecasted Sales (Sterling) for Period", precision=2, visible=False)

            overall_plot = gr.Plot(label="Overall Sales Forecast Plot")
            gr.Markdown("This graph illustrates the overall daily sales forecast, showing the predicted trend and confidence intervals.")

            overall_components = gr.Plot(label="Overall Sales Forecast Components")
            gr.Markdown("This graph breaks down the overall sales forecast into its underlying components: trend, weekly seasonality, and yearly seasonality.")

            overall_btn.click(
                fn=predict_overall_sales,
                inputs=[overall_days, overall_output_choice],
                outputs=[overall_table, overall_total_output, overall_plot, overall_components]
            )

        with gr.Tab("Product Demand Forecast"):
            gr.Markdown("### 📦 Forecast Product Demand")
            product_selector = gr.Dropdown(
                label="Select the Product ID:",
                choices=list(demand_models.keys()) if top_products else ["No products loaded"],
                value=list(demand_models.keys())[0] if top_products else None,
                interactive=True
            )
            product_days = gr.Number(
                label="Enter number of future days to forecast:",
                value=30,
                minimum=7,
                maximum=365,
                step=7
            )
            product_output_choice = gr.Radio(
                ["Detailed Table", "Total Sum for Period"],
                label="Choose Output Format",
                value="Detailed Table",
                interactive=True
            )
            product_btn = gr.Button("Forecast Demand")

            gr.Markdown("""
            **Note on Negative Values:** Negative quantities in the forecast, indicate a **prediction of returned orders** for that specific product during that period.
            """)

            product_table = gr.DataFrame(label="Forecast Data Table", visible=True)
            product_total_output = gr.Number(label="Total Forecasted Quantity for Period", precision=2, visible=False)

            product_plot = gr.Plot(label="Demand Forecast Plot")
            gr.Markdown("This graph illustrates the daily demand forecast for the selected product, showing the predicted trend and confidence intervals.")

            product_components = gr.Plot(label="Demand Forecast Components")
            gr.Markdown("This graph breaks down the product demand forecast into its underlying components: trend, weekly seasonality, and yearly seasonality.")

            product_btn.click(
                fn=predict_product_demand,
                inputs=[product_selector, product_days, product_output_choice],
                outputs=[product_table, product_total_output, product_plot, product_components]
            )

        # --- NEW CLV TAB (UPDATED) ---
        with gr.Tab("Customer Lifetime Value (CLV) Predictor"): # Change 1: Added "Predictor"
            gr.Markdown("### 💰 Predict Customer Lifetime Value")
            gr.Markdown("This section predicts the future monetary value a customer will bring to the business.")

            clv_periods = gr.Slider(
                minimum=1,
                maximum=24, # Predicting for up to 24 months (2 years)
                value=12,
                step=1,
                label="Number of Future Months to Predict CLV For:"
            )

            # Change 3: Added slider for number of results
            clv_results_count = gr.Slider(
                minimum=1,
                maximum=100, # Max number of top customers to show
                value=20, # Default to showing 20 top customers
                step=1,
                label="Number of Top Customers to Display (Max 100):"
            )

            # Optional: Allow prediction for a specific customer ID
            clv_customer_id = gr.Number(
                label="Enter a specific Customer ID (optional, leave blank for overall top customers):",
                interactive=True
            )
            # Change 4: Added example IDs
            gr.Markdown("Example Customer IDs: `17850`, `13047`, `12583`")

            clv_btn = gr.Button("Predict CLV")

            gr.Markdown("""
            **Note:** CLV is predicted based on the expected number of future purchases and the expected average monetary value per purchase.
            """)

            # Change 7: Added note about negative CLV
            gr.Markdown("""
            **Note on Negative CLV:** A negative Customer Lifetime Value indicates that, based on historical patterns, a customer is predicted to generate a net loss for the business during the specified prediction period (e.g., due to returns outweighing purchases).
            """)

            clv_output_df = gr.DataFrame(
                label="Predicted Customer Lifetime Value (Top Customers or Specific ID)",
                visible=True,
                headers=["CustomerID", "Predicted CLV (£)"] # Change 2: Added unit
            )

            clv_btn.click(
                fn=predict_clv,
                inputs=[clv_periods, clv_results_count, clv_customer_id], # Change 3: Added customers_to_show
                outputs=[clv_output_df]
            )


    # --- Footer (UPDATED) ---
    gr.Markdown("""
    ---
    *Developed with Python, Pandas, NumPy, Matplotlib, Seaborn, Gradio (for UI), Prophet (for Sales & Demand), Lifetimes (for CLV), ucimlrepo (for data fetching), and dill (for model serialization).*
    """)

# --- Launch App ---
if __name__ == "__main__":
    demo.launch()
